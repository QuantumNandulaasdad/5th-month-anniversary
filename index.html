<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ikku's maze <3</title>
<style>
  body {
    margin: 0;
    background: #f1bcd4;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
  }
  h1 {
    font-size: 2em;
    background: repeating-linear-gradient(45deg, white, white 10px, pink 10px, pink 20px);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 10px;
  }
  canvas {
    background: #58CCED;
    display: block;
    touch-action: none;
    border-radius: 12px;
  }
  #popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    display: none;
    align-items: center;
    justify-content: center;
  }
  #popup img, #popup iframe {
    max-width: 95%;
    max-height: 95%;
    border-radius: 12px;
    box-shadow: 0 0 20px white;
  }
</style>
</head>
<body>
  <h1>Ikku's maze <3</h1>
  <canvas id="mazeCanvas"></canvas>
  <div id="popup"></div>

  <!-- ðŸŽµ Hidden audio players -->
  <audio id="winSound" src="sodapop.mp3"></audio>
  <audio id="pinkSound" src="Bruno Mars - Just The Way You Are (Lyrics).mp3"></audio>

<script>
const canvas = document.getElementById("mazeCanvas");
const ctx = canvas.getContext("2d");
let mazeSize = 25; 
let cellSize;
let maze = [];
let player = {x:0,y:0};

// exits
let exits = [
  {x:mazeSize-1, y:mazeSize-1, color:"pink", type:"image", src:"like.jpg"}, 
  {x:0, y:mazeSize-1, color:"black", type:"youtube", src:"https://www.youtube.com/embed/7ML8jdq3-sA"},
  {x:mazeSize-1, y:0, color:"red", type:"image", src:"kau.png"} // ðŸ”´ red heart uses uploaded image
];

// âœ… Full Maze Layout
function generateMaze() {
  maze = [
    [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,0],
    [1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,1,0],
    [1,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0],
    [1,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0],
    [0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0],
    [0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0],
    [0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0],
    [0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0],
    [0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0],
    [0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0],
    [0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],
    [0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,0],
    [0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0],
    [0,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,0],
    [0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0],
    [0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0],
    [0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0],
    [0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0],
    [0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];
}

function resizeCanvas() {
  let minDimension = Math.min(window.innerWidth, window.innerHeight) * 0.9;
  canvas.width = minDimension;
  canvas.height = minDimension;
  cellSize = canvas.width / mazeSize;
  drawMaze();
}

function drawMaze() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for (let y=0;y<mazeSize;y++) {
    for (let x=0;x<mazeSize;x++) {
      if (!maze[y][x]) {
        ctx.fillStyle = "#333";
        ctx.fillRect(x*cellSize,y*cellSize,cellSize,cellSize);
      }
    }
  }
  drawPlayer(player.x, player.y);
  exits.forEach(e => drawHeart(e.x, e.y, e.color));
}

function drawPlayer(x, y){
  const cx = x*cellSize + cellSize/2;
  const cy = y*cellSize + cellSize/2;
  const r = cellSize*0.3;
  ctx.fillStyle = "white";
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI*2);
  ctx.fill();
}

function drawHeart(x, y, color) {
  const cx = x*cellSize + cellSize/2;
  const cy = y*cellSize + cellSize/2;
  const r = cellSize*0.3;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(cx, cy + r/2);
  ctx.bezierCurveTo(cx + r, cy - r/2, cx + r, cy + r, cx, cy + r*1.5);
  ctx.bezierCurveTo(cx - r, cy + r, cx - r, cy - r/2, cx, cy + r/2);
  ctx.fill();
}

function movePlayer(dx,dy) {
  let nx = player.x+dx;
  let ny = player.y+dy;
  if (nx>=0 && ny>=0 && nx<mazeSize && ny<mazeSize && maze[ny][nx]) {
    player.x = nx;
    player.y = ny;
    drawMaze();
    exits.forEach(e => {
      if(player.x===e.x && player.y===e.y){
        const popup = document.getElementById("popup");
        popup.innerHTML = ""; // clear old content

        if (e.type === "image") {
          const img = document.createElement("img");
          img.src = e.src;
          popup.appendChild(img);
        } else if (e.type === "youtube") {
          const iframe = document.createElement("iframe");
          iframe.src = e.src + "?autoplay=1";
          iframe.width = "560";
          iframe.height = "315";
          iframe.frameBorder = "0";
          iframe.allow = "autoplay; encrypted-media";
          iframe.allowFullscreen = true;
          popup.appendChild(iframe);
        }

        popup.style.display = "flex";

        // ðŸŽµ Play sound depending on heart color
        if (e.color === "red") {
          const audio = document.getElementById("winSound");
          audio.currentTime = 0;
          audio.play();
        }
        if (e.color === "pink") {
          const audio = document.getElementById("pinkSound");
          audio.currentTime = 0;
          audio.play();
        }
      }
    });
  }
}

window.addEventListener("keydown", e => {
  if (e.key==="ArrowUp"||e.key==="w") movePlayer(0,-1);
  if (e.key==="ArrowDown"||e.key==="s") movePlayer(0,1);
  if (e.key==="ArrowLeft"||e.key==="a") movePlayer(-1,0);
  if (e.key==="ArrowRight"||e.key==="d") movePlayer(1,0);
});

let touchStartX, touchStartY;
canvas.addEventListener("touchstart", e => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
});
canvas.addEventListener("touchend", e => {
  let dx = e.changedTouches[0].clientX - touchStartX;
  let dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx)>Math.abs(dy)) {
    if (dx>30) movePlayer(1,0);
    else if (dx<-30) movePlayer(-1,0);
  } else {
    if (dy>30) movePlayer(0,1);
    else if (dy<-30) movePlayer(0,-1);
  }
});

window.addEventListener("resize", resizeCanvas);
generateMaze();
resizeCanvas();
drawMaze();
</script>
</body>
</html>
